Step 1: Project Setup
Initialize the Node.js Project:

bash
Copy code
mkdir vehicle-booking-backend
cd vehicle-booking-backend
npm init -y
Install Dependencies:

bash
Copy code
npm install express mysql2 dotenv
Express: For creating the API endpoints.
mysql2: MySQL library for connecting and querying MySQL database.
dotenv: For managing environment variables.
Project Structure:

bash
Copy code
vehicle-booking-backend/
├── config/
│   └── db.js            # Database connection setup
├── migrations/          # SQL migration files
├── seeders/             # SQL seed files
├── controllers/         # API controllers
├── routes/              # Express routes
├── .env                 # Environment variables
├── app.js               # Express app setup
└── server.js            # Server initialization
Step 2: Configure Environment Variables
Create a .env file to store the database configuration:

plaintext
Copy code
DB_HOST=localhost
DB_USER=your_username
DB_PASSWORD=your_password
DB_NAME=vehicle_booking
DB_PORT=3306
Create Database Connection: In config/db.js, configure the connection to the MySQL database:

javascript
Copy code
const mysql = require('mysql2');
require('dotenv').config();

const pool = mysql.createPool({
  host: process.env.DB_HOST,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  port: process.env.DB_PORT,
  waitForConnections: true,
  connectionLimit: 10,
  queueLimit: 0
});

module.exports = pool.promise();
Step 3: Create Database Migrations
In the migrations folder, create a SQL migration file (20231109_create_tables.sql) to define the database schema:

sql
Copy code
-- Create vehicle types table
CREATE TABLE IF NOT EXISTS VehicleTypes (
    id INT AUTO_INCREMENT PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    wheels INT NOT NULL
);

-- Create vehicles table
CREATE TABLE IF NOT EXISTS Vehicles (
    id INT AUTO_INCREMENT PRIMARY KEY,
    type_id INT,
    name VARCHAR(255) NOT NULL,
    FOREIGN KEY (type_id) REFERENCES VehicleTypes(id)
);

-- Create bookings table
CREATE TABLE IF NOT EXISTS Bookings (
    id INT AUTO_INCREMENT PRIMARY KEY,
    vehicle_id INT,
    start_date DATE NOT NULL,
    end_date DATE NOT NULL,
    FOREIGN KEY (vehicle_id) REFERENCES Vehicles(id)
);
Run this SQL script in MySQL to create the tables.

Step 4: Seed Initial Data
Create a seed SQL file (seeders/20231109_seed_initial_data.sql) to populate the database with initial values:

sql
Copy code
-- Insert vehicle types
INSERT INTO VehicleTypes (name, wheels) VALUES ('Hatchback', 4), ('SUV', 4), ('Sedan', 4), ('Cruiser', 2);

-- Insert vehicles
INSERT INTO Vehicles (type_id, name) VALUES
    (1, 'Toyota Yaris'),
    (1, 'Honda Jazz'),
    (2, 'Ford Explorer'),
    (2, 'Jeep Wrangler'),
    (3, 'BMW 3 Series'),
    (3, 'Audi A4'),
    (4, 'Harley Davidson Sportster'),
    (4, 'Royal Enfield Classic');
To apply the seed data, execute this SQL script in the database.

Step 5: Design the APIs
API to Fetch Vehicle Types and Models Based on Wheels:

In controllers/vehicleController.js:

javascript
Copy code
const db = require('../config/db');

exports.getVehiclesByWheels = async (req, res) => {
  const { wheels } = req.query;

  try {
    const [rows] = await db.query(`
      SELECT VehicleTypes.name AS type, Vehicles.name AS vehicle 
      FROM VehicleTypes 
      JOIN Vehicles ON VehicleTypes.id = Vehicles.type_id 
      WHERE VehicleTypes.wheels = ?
    `, [wheels]);

    res.json(rows);
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};
Route: In routes/vehicleRoutes.js:

javascript
Copy code
const express = require('express');
const router = express.Router();
const vehicleController = require('../controllers/vehicleController');

router.get('/vehicles', vehicleController.getVehiclesByWheels);

module.exports = router;
Submit Booking API:

In controllers/bookingController.js:

javascript
Copy code
const db = require('../config/db');

exports.createBooking = async (req, res) => {
  const { vehicleId, startDate, endDate } = req.body;

  try {
    // Check for overlapping bookings
    const [overlaps] = await db.query(`
      SELECT * FROM Bookings 
      WHERE vehicle_id = ? 
      AND (start_date BETWEEN ? AND ? OR end_date BETWEEN ? AND ?)
    `, [vehicleId, startDate, endDate, startDate, endDate]);

    if (overlaps.length > 0) {
      return res.status(400).json({ message: 'This vehicle is already booked for the selected dates.' });
    }

    // Insert new booking
    await db.query(`
      INSERT INTO Bookings (vehicle_id, start_date, end_date) 
      VALUES (?, ?, ?)
    `, [vehicleId, startDate, endDate]);

    res.status(201).json({ message: 'Booking created successfully!' });
  } catch (err) {
    res.status(500).json({ error: err.message });
  }
};
Route: In routes/bookingRoutes.js:

javascript
Copy code
const express = require('express');
const router = express.Router();
const bookingController = require('../controllers/bookingController');

router.post('/bookings', bookingController.createBooking);

module.exports = router;
Integrate Routes in app.js:

javascript
Copy code
const express = require('express');
const app = express();
const vehicleRoutes = require('./routes/vehicleRoutes');
const bookingRoutes = require('./routes/bookingRoutes');

app.use(express.json());
app.use('/api', vehicleRoutes);
app.use('/api', bookingRoutes);

module.exports = app;
Step 6: Start the Server
Create server.js to start the application:

javascript
Copy code
const app = require('./app');
const PORT = process.env.PORT || 3000;

app.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});
Run the server:

bash
Copy code
node server.js
Summary
Seeding Initial Data: We have a SQL file in the seeders folder to insert predefined vehicle types and models.
APIs:
/api/vehicles: Fetches vehicle types and models based on the number of wheels.
/api/bookings: Creates a booking for a vehicle and checks for overlapping bookings.
Migrations: The migrations folder contains an SQL file to set up the necessary database tables.
Repository Structure: Make sure all SQL scripts (for seeding and migrations) are committed to the repository, so other developers can easily set up the database by running the migrations and seeders.